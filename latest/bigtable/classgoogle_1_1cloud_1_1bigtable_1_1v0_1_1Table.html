<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google Cloud Bigtable C++ Client: google::cloud::bigtable::v0::Table Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Google Cloud Bigtable C++ Client
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
   <div id="projectbrief">A C++ Client Library for Google Cloud Bigtable</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegoogle.html">google</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud.html">cloud</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud_1_1bigtable.html">bigtable</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html">v0</a></li><li class="navelem"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html">Table</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">google::cloud::bigtable::v0::Table Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The main interface to interact with data in a Cloud Bigtable table.  
 <a href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="table_8h_source.html">google/cloud/bigtable/table.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7360745d0302bcf42e08dce2b40f088f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a7360745d0302bcf42e08dce2b40f088f">Table</a> (std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1DataClient.html">DataClient</a> &gt; client, std::string const &amp;table_id)</td></tr>
<tr class="memdesc:a7360745d0302bcf42e08dce2b40f088f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with default policies.  <a href="#a7360745d0302bcf42e08dce2b40f088f">More...</a><br /></td></tr>
<tr class="separator:a7360745d0302bcf42e08dce2b40f088f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71933c08e2b1ed812c353af336fae6c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a71933c08e2b1ed812c353af336fae6c5">Table</a> (std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1DataClient.html">DataClient</a> &gt; client, bigtable::AppProfileId app_profile_id, std::string const &amp;table_id)</td></tr>
<tr class="memdesc:a71933c08e2b1ed812c353af336fae6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with default policies.  <a href="#a71933c08e2b1ed812c353af336fae6c5">More...</a><br /></td></tr>
<tr class="separator:a71933c08e2b1ed812c353af336fae6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2bf9d9255ea04b97b2531b728d85f21"><td class="memTemplParams" colspan="2">template&lt;typename RPCRetryPolicy , typename RPCBackoffPolicy , typename IdempotentMutationPolicy &gt; </td></tr>
<tr class="memitem:aa2bf9d9255ea04b97b2531b728d85f21"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#aa2bf9d9255ea04b97b2531b728d85f21">Table</a> (std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1DataClient.html">DataClient</a> &gt; client, std::string const &amp;table_id, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCRetryPolicy.html">RPCRetryPolicy</a> retry_policy, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCBackoffPolicy.html">RPCBackoffPolicy</a> backoff_policy, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1IdempotentMutationPolicy.html">IdempotentMutationPolicy</a> idempotent_mutation_policy)</td></tr>
<tr class="memdesc:aa2bf9d9255ea04b97b2531b728d85f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with explicit policies.  <a href="#aa2bf9d9255ea04b97b2531b728d85f21">More...</a><br /></td></tr>
<tr class="separator:aa2bf9d9255ea04b97b2531b728d85f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47815ea4b1a28bfa75b3ec69f5d63f2"><td class="memTemplParams" colspan="2">template&lt;typename RPCRetryPolicy , typename RPCBackoffPolicy , typename IdempotentMutationPolicy &gt; </td></tr>
<tr class="memitem:ac47815ea4b1a28bfa75b3ec69f5d63f2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#ac47815ea4b1a28bfa75b3ec69f5d63f2">Table</a> (std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1DataClient.html">DataClient</a> &gt; client, bigtable::AppProfileId app_profile_id, std::string const &amp;table_id, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCRetryPolicy.html">RPCRetryPolicy</a> retry_policy, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCBackoffPolicy.html">RPCBackoffPolicy</a> backoff_policy, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1IdempotentMutationPolicy.html">IdempotentMutationPolicy</a> idempotent_mutation_policy)</td></tr>
<tr class="memdesc:ac47815ea4b1a28bfa75b3ec69f5d63f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with explicit policies.  <a href="#ac47815ea4b1a28bfa75b3ec69f5d63f2">More...</a><br /></td></tr>
<tr class="separator:ac47815ea4b1a28bfa75b3ec69f5d63f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a84118bf4f098d5a4785b586484ab14"><td class="memItemLeft" align="right" valign="top">std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a1a84118bf4f098d5a4785b586484ab14">table_name</a> () const</td></tr>
<tr class="separator:a1a84118bf4f098d5a4785b586484ab14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ba917df84436b0f4daee0d65f8b477"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a64ba917df84436b0f4daee0d65f8b477">Apply</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1SingleRowMutation.html">SingleRowMutation</a> &amp;&amp;mut)</td></tr>
<tr class="memdesc:a64ba917df84436b0f4daee0d65f8b477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to apply the mutation to a row.  <a href="#a64ba917df84436b0f4daee0d65f8b477">More...</a><br /></td></tr>
<tr class="separator:a64ba917df84436b0f4daee0d65f8b477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ccadae90b76ffe2f78d1b49109e701"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#ad4ccadae90b76ffe2f78d1b49109e701">BulkApply</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1BulkMutation.html">BulkMutation</a> &amp;&amp;mut)</td></tr>
<tr class="memdesc:ad4ccadae90b76ffe2f78d1b49109e701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to apply mutations to multiple rows.  <a href="#ad4ccadae90b76ffe2f78d1b49109e701">More...</a><br /></td></tr>
<tr class="separator:ad4ccadae90b76ffe2f78d1b49109e701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fd0b3bc5b4fc17db8e3f099aaf9c33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RowReader.html">RowReader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a07fd0b3bc5b4fc17db8e3f099aaf9c33">ReadRows</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RowSet.html">RowSet</a> row_set, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Filter.html">Filter</a> filter)</td></tr>
<tr class="memdesc:a07fd0b3bc5b4fc17db8e3f099aaf9c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a set of rows from the table.  <a href="#a07fd0b3bc5b4fc17db8e3f099aaf9c33">More...</a><br /></td></tr>
<tr class="separator:a07fd0b3bc5b4fc17db8e3f099aaf9c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95295dc0c3dd50603926b6038160a071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RowReader.html">RowReader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a95295dc0c3dd50603926b6038160a071">ReadRows</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RowSet.html">RowSet</a> row_set, std::int64_t rows_limit, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Filter.html">Filter</a> filter)</td></tr>
<tr class="memdesc:a95295dc0c3dd50603926b6038160a071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a limited set of rows from the table.  <a href="#a95295dc0c3dd50603926b6038160a071">More...</a><br /></td></tr>
<tr class="separator:a95295dc0c3dd50603926b6038160a071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6170060c579d2fbd6b29a4ba6f7de434"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Row.html">Row</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a6170060c579d2fbd6b29a4ba6f7de434">ReadRow</a> (std::string row_key, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Filter.html">Filter</a> filter)</td></tr>
<tr class="memdesc:a6170060c579d2fbd6b29a4ba6f7de434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and return a single row from the table.  <a href="#a6170060c579d2fbd6b29a4ba6f7de434">More...</a><br /></td></tr>
<tr class="separator:a6170060c579d2fbd6b29a4ba6f7de434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75595485f6207799a52b296d4f45d27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#aa75595485f6207799a52b296d4f45d27">CheckAndMutateRow</a> (std::string row_key, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Filter.html">Filter</a> filter, std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Mutation.html">Mutation</a> &gt; true_mutations, std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Mutation.html">Mutation</a> &gt; false_mutations)</td></tr>
<tr class="memdesc:aa75595485f6207799a52b296d4f45d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic test-and-set for a row using filter expressions.  <a href="#aa75595485f6207799a52b296d4f45d27">More...</a><br /></td></tr>
<tr class="separator:aa75595485f6207799a52b296d4f45d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13ee373480b6eded62945b506a4e753"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; class Collection = std::vector&gt; </td></tr>
<tr class="memitem:ad13ee373480b6eded62945b506a4e753"><td class="memTemplItemLeft" align="right" valign="top">Collection&lt; bigtable::RowKeySample &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#ad13ee373480b6eded62945b506a4e753">SampleRows</a> ()</td></tr>
<tr class="memdesc:ad13ee373480b6eded62945b506a4e753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample of the row keys in the table, including approximate data sizes.  <a href="#ad13ee373480b6eded62945b506a4e753">More...</a><br /></td></tr>
<tr class="separator:ad13ee373480b6eded62945b506a4e753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23d1796d60442eac811eac99808ad9f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:af23d1796d60442eac811eac99808ad9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Row.html">Row</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#af23d1796d60442eac811eac99808ad9f">ReadModifyWriteRow</a> (std::string row_key, bigtable::ReadModifyWriteRule rule, Args &amp;&amp;... rules)</td></tr>
<tr class="memdesc:af23d1796d60442eac811eac99808ad9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read and modify the row in the server, returning the resulting row.  <a href="#af23d1796d60442eac811eac99808ad9f">More...</a><br /></td></tr>
<tr class="separator:af23d1796d60442eac811eac99808ad9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main interface to interact with data in a Cloud Bigtable table. </p>
<p>This class provides member functions to:</p><ul>
<li>read specific rows: <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a6170060c579d2fbd6b29a4ba6f7de434" title="Read and return a single row from the table. ">Table::ReadRow()</a></code></li>
<li>scan a ranges of rows: <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a07fd0b3bc5b4fc17db8e3f099aaf9c33" title="Reads a set of rows from the table. ">Table::ReadRows()</a></code></li>
<li>update or create a single row: <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a64ba917df84436b0f4daee0d65f8b477" title="Attempts to apply the mutation to a row. ">Table::Apply()</a></code></li>
<li>update or modify multiple rows: <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#ad4ccadae90b76ffe2f78d1b49109e701" title="Attempts to apply mutations to multiple rows. ">Table::BulkApply()</a></code></li>
<li>update a row based on previous values: <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#aa75595485f6207799a52b296d4f45d27" title="Atomic test-and-set for a row using filter expressions. ">Table::CheckAndMutateRow()</a></code></li>
</ul>
<p>The class deals with the most common transient failures, and retries the underlying RPC calls subject to the policies configured by the application. These policies are documented in<code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a7360745d0302bcf42e08dce2b40f088f" title="Constructor with default policies. ">Table::Table()</a></code>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7360745d0302bcf42e08dce2b40f088f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7360745d0302bcf42e08dce2b40f088f">&#9670;&nbsp;</a></span>Table() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::cloud::bigtable::v0::Table::Table </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1DataClient.html">DataClient</a> &gt;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>table_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with default policies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>how to communicate with Cloud Bigtable, including credentials, the project id, and the instance id. </td></tr>
    <tr><td class="paramname">table_id</td><td>the table id within the instance defined by client. The full table name is `client-&gt;instance_name() + '/tables/' + table_id`. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71933c08e2b1ed812c353af336fae6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71933c08e2b1ed812c353af336fae6c5">&#9670;&nbsp;</a></span>Table() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::cloud::bigtable::v0::Table::Table </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1DataClient.html">DataClient</a> &gt;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::AppProfileId&#160;</td>
          <td class="paramname"><em>app_profile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>table_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with default policies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>how to communicate with Cloud Bigtable, including credentials, the project id, and the instance id. </td></tr>
    <tr><td class="paramname">app_profile_id</td><td>the app_profile_id needed for using replication and snapshot APIs. </td></tr>
    <tr><td class="paramname">table_id</td><td>the table id within the instance defined by client. The full table name is `client-&gt;instance_name() + '/tables/' + table_id`. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2bf9d9255ea04b97b2531b728d85f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2bf9d9255ea04b97b2531b728d85f21">&#9670;&nbsp;</a></span>Table() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RPCRetryPolicy , typename RPCBackoffPolicy , typename IdempotentMutationPolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::cloud::bigtable::v0::Table::Table </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1DataClient.html">DataClient</a> &gt;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCRetryPolicy.html">RPCRetryPolicy</a>&#160;</td>
          <td class="paramname"><em>retry_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCBackoffPolicy.html">RPCBackoffPolicy</a>&#160;</td>
          <td class="paramname"><em>backoff_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1IdempotentMutationPolicy.html">IdempotentMutationPolicy</a>&#160;</td>
          <td class="paramname"><em>idempotent_mutation_policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with explicit policies. </p>
<p>The policies are passed by value, because this makes it easy for applications to create them. For example:</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::chrono_literals; <span class="comment">// assuming C++14.</span></div><div class="line"><span class="keyword">auto</span> client = bigtable::CreateDefaultClient(...); <span class="comment">// details ommitted</span></div><div class="line">bigtable::Table table(client, <span class="stringliteral">&quot;my-table&quot;</span>,</div><div class="line">                      <span class="comment">// Allow up to 20 minutes to retry operations</span></div><div class="line">                      bigtable::LimitedTimeRetryPolicy(20min),</div><div class="line">                      <span class="comment">// Start with 50 milliseconds backoff, grow</span></div><div class="line">                      <span class="comment">// exponentially to 5 minutes.</span></div><div class="line">                      bigtable::ExponentialBackoffPolicy(50ms, 5min),</div><div class="line">                      <span class="comment">// Only retry idempotent mutations.</span></div><div class="line">                      bigtable::SafeIdempotentMutationPolicy());</div></div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>how to communicate with Cloud Bigtable, including credentials, the project id, and the instance id. </td></tr>
    <tr><td class="paramname">table_id</td><td>the table id within the instance defined by client. The full table name is <code>client-&gt;instance_name() + "/tables/" + table_id</code>. </td></tr>
    <tr><td class="paramname">retry_policy</td><td>the value of the <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCRetryPolicy.html" title="Define the interface for controlling how the Bigtable client retries RPC operations. ">RPCRetryPolicy</a></code>, for example, the policy type may be <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1LimitedErrorCountRetryPolicy.html" title="Implement a simple &quot;count errors and then stop&quot; retry policy. ">LimitedErrorCountRetryPolicy</a></code> which tolerates a maximum number of errors, the value controls how many. </td></tr>
    <tr><td class="paramname">backoff_policy</td><td>the value of the <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCBackoffPolicy.html" title="Define the interface for controlling how the Bigtable client backsoff from failed RPC operations...">RPCBackoffPolicy</a></code>, for example, the policy type may be <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ExponentialBackoffPolicy.html" title="Implement a simple exponential backoff policy. ">ExponentialBackoffPolicy</a></code> which will double the wait period on each failure, up to a limit. The value controls the initial and maximum wait periods. </td></tr>
    <tr><td class="paramname">idempotent_mutation_policy</td><td>the value of the <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1IdempotentMutationPolicy.html" title="Defines the interface to control which mutations are idempotent and therefore can be re-tried...">IdempotentMutationPolicy</a></code>. The policies implemented by this library (<code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1SafeIdempotentMutationPolicy.html" title="Implements a policy that only accepts truly idempotent mutations. ">SafeIdempotentMutationPolicy</a></code> and <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1AlwaysRetryMutationPolicy.html" title="Implements a policy that retries all mutations. ">AlwaysRetryMutationPolicy</a></code>) are stateless, but the application may implement stateful policies.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1IdempotentMutationPolicy.html" title="Defines the interface to control which mutations are idempotent and therefore can be re-tried...">IdempotentMutationPolicy</a></td><td>which mutations are retried. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1SafeIdempotentMutationPolicy.html" title="Implements a policy that only accepts truly idempotent mutations. ">SafeIdempotentMutationPolicy</a></code> to only retry idempotent operations, use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1AlwaysRetryMutationPolicy.html" title="Implements a policy that retries all mutations. ">AlwaysRetryMutationPolicy</a></code> to retry all operations. Read the caveats in the class defintion to understand the downsides of the latter. You can also create your own policies that decide which mutations to retry. </td></tr>
    <tr><td class="paramname"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCBackoffPolicy.html" title="Define the interface for controlling how the Bigtable client backsoff from failed RPC operations...">RPCBackoffPolicy</a></td><td>how to backoff from a failed RPC. Currently only <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ExponentialBackoffPolicy.html" title="Implement a simple exponential backoff policy. ">ExponentialBackoffPolicy</a></code> is implemented. You can also create your own policies that backoff using a different algorithm. </td></tr>
    <tr><td class="paramname"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCRetryPolicy.html" title="Define the interface for controlling how the Bigtable client retries RPC operations. ">RPCRetryPolicy</a></td><td>for how long to retry failed RPCs. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1LimitedErrorCountRetryPolicy.html" title="Implement a simple &quot;count errors and then stop&quot; retry policy. ">LimitedErrorCountRetryPolicy</a></code> to limit the number of failures allowed. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1LimitedTimeRetryPolicy.html" title="Implement a simple &quot;keep trying for this time&quot; retry policy. ">LimitedTimeRetryPolicy</a></code> to bound the time for any request. You can also create your own policies that combine time and error counts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac47815ea4b1a28bfa75b3ec69f5d63f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47815ea4b1a28bfa75b3ec69f5d63f2">&#9670;&nbsp;</a></span>Table() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RPCRetryPolicy , typename RPCBackoffPolicy , typename IdempotentMutationPolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::cloud::bigtable::v0::Table::Table </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1DataClient.html">DataClient</a> &gt;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::AppProfileId&#160;</td>
          <td class="paramname"><em>app_profile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCRetryPolicy.html">RPCRetryPolicy</a>&#160;</td>
          <td class="paramname"><em>retry_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCBackoffPolicy.html">RPCBackoffPolicy</a>&#160;</td>
          <td class="paramname"><em>backoff_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1IdempotentMutationPolicy.html">IdempotentMutationPolicy</a>&#160;</td>
          <td class="paramname"><em>idempotent_mutation_policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with explicit policies. </p>
<p>The policies are passed by value, because this makes it easy for applications to create them. For example:</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::chrono_literals; <span class="comment">// assuming C++14.</span></div><div class="line"><span class="keyword">auto</span> client = bigtable::CreateDefaultClient(...); <span class="comment">// details ommitted</span></div><div class="line">bigtable::Table table(client, <span class="stringliteral">&quot;app_id&quot;</span>, <span class="stringliteral">&quot;my-table&quot;</span>,</div><div class="line">                      <span class="comment">// Allow up to 20 minutes to retry operations</span></div><div class="line">                      bigtable::LimitedTimeRetryPolicy(20min),</div><div class="line">                      <span class="comment">// Start with 50 milliseconds backoff, grow</span></div><div class="line">                      <span class="comment">// exponentially to 5 minutes.</span></div><div class="line">                      bigtable::ExponentialBackoffPolicy(50ms, 5min),</div><div class="line">                      <span class="comment">// Only retry idempotent mutations.</span></div><div class="line">                      bigtable::SafeIdempotentMutationPolicy());</div></div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>how to communicate with Cloud Bigtable, including credentials, the project id, and the instance id. </td></tr>
    <tr><td class="paramname">app_profile_id</td><td>the app_profile_id needed for using replication and snapshot APIs. </td></tr>
    <tr><td class="paramname">table_id</td><td>the table id within the instance defined by client. The full table name is <code>client-&gt;instance_name() + "/tables/" + table_id</code>. </td></tr>
    <tr><td class="paramname">retry_policy</td><td>the value of the <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCRetryPolicy.html" title="Define the interface for controlling how the Bigtable client retries RPC operations. ">RPCRetryPolicy</a></code>, for example, the policy type may be <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1LimitedErrorCountRetryPolicy.html" title="Implement a simple &quot;count errors and then stop&quot; retry policy. ">LimitedErrorCountRetryPolicy</a></code> which tolerates a maximum number of errors, the value controls how many. </td></tr>
    <tr><td class="paramname">backoff_policy</td><td>the value of the <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCBackoffPolicy.html" title="Define the interface for controlling how the Bigtable client backsoff from failed RPC operations...">RPCBackoffPolicy</a></code>, for example, the policy type may be <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ExponentialBackoffPolicy.html" title="Implement a simple exponential backoff policy. ">ExponentialBackoffPolicy</a></code> which will double the wait period on each failure, up to a limit. The value controls the initial and maximum wait periods. </td></tr>
    <tr><td class="paramname">idempotent_mutation_policy</td><td>the value of the <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1IdempotentMutationPolicy.html" title="Defines the interface to control which mutations are idempotent and therefore can be re-tried...">IdempotentMutationPolicy</a></code>. The policies implemented by this library (<code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1SafeIdempotentMutationPolicy.html" title="Implements a policy that only accepts truly idempotent mutations. ">SafeIdempotentMutationPolicy</a></code> and <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1AlwaysRetryMutationPolicy.html" title="Implements a policy that retries all mutations. ">AlwaysRetryMutationPolicy</a></code>) are stateless, but the application may implement stateful policies.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1IdempotentMutationPolicy.html" title="Defines the interface to control which mutations are idempotent and therefore can be re-tried...">IdempotentMutationPolicy</a></td><td>which mutations are retried. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1SafeIdempotentMutationPolicy.html" title="Implements a policy that only accepts truly idempotent mutations. ">SafeIdempotentMutationPolicy</a></code> to only retry idempotent operations, use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1AlwaysRetryMutationPolicy.html" title="Implements a policy that retries all mutations. ">AlwaysRetryMutationPolicy</a></code> to retry all operations. Read the caveats in the class defintion to understand the downsides of the latter. You can also create your own policies that decide which mutations to retry. </td></tr>
    <tr><td class="paramname"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCBackoffPolicy.html" title="Define the interface for controlling how the Bigtable client backsoff from failed RPC operations...">RPCBackoffPolicy</a></td><td>how to backoff from a failed RPC. Currently only <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ExponentialBackoffPolicy.html" title="Implement a simple exponential backoff policy. ">ExponentialBackoffPolicy</a></code> is implemented. You can also create your own policies that backoff using a different algorithm. </td></tr>
    <tr><td class="paramname"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCRetryPolicy.html" title="Define the interface for controlling how the Bigtable client retries RPC operations. ">RPCRetryPolicy</a></td><td>for how long to retry failed RPCs. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1LimitedErrorCountRetryPolicy.html" title="Implement a simple &quot;count errors and then stop&quot; retry policy. ">LimitedErrorCountRetryPolicy</a></code> to limit the number of failures allowed. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1LimitedTimeRetryPolicy.html" title="Implement a simple &quot;keep trying for this time&quot; retry policy. ">LimitedTimeRetryPolicy</a></code> to bound the time for any request. You can also create your own policies that combine time and error counts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a64ba917df84436b0f4daee0d65f8b477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ba917df84436b0f4daee0d65f8b477">&#9670;&nbsp;</a></span>Apply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void google::cloud::bigtable::v0::Table::Apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1SingleRowMutation.html">SingleRowMutation</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>mut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to apply the mutation to a row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut</td><td>the mutation. Note that this function takes ownership (and then discards) the data in the mutation. In general, a <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1SingleRowMutation.html" title="Represent a single row mutation. ">SingleRowMutation</a></code> can be used to modify and/or delete multiple cells, across different columns and column families.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1PermanentMutationFailure.html" title="Report unrecoverable errors in a partially completed mutation. ">PermanentMutationFailure</a></td><td>if the function cannot successfully apply the mutation given the current policies. The exception contains a copy of the original mutation, in case the application wants to retry, log, or otherwise handle the failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a64ba917df84436b0f4daee0d65f8b477">Apply</a>(google::cloud::bigtable::Table table) {</div><div class="line">  <span class="comment">// Write several rows with some trivial data.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != 20; ++i) {</div><div class="line">    <span class="comment">// Note: This example uses sequential numeric IDs for simplicity, but</span></div><div class="line">    <span class="comment">// this can result in poor performance in a production application.</span></div><div class="line">    <span class="comment">// Since rows are stored in sorted order by key, sequential keys can</span></div><div class="line">    <span class="comment">// result in poor distribution of operations across nodes.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// For more information about how to design a Bigtable schema for the</span></div><div class="line">    <span class="comment">// best performance, see the documentation:</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//     https://cloud.google.com/bigtable/docs/schema-design</span></div><div class="line">    <span class="keywordtype">char</span> buf[32];</div><div class="line">    snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">&quot;key-%06d&quot;</span>, i);</div><div class="line">    google::cloud::bigtable::SingleRowMutation mutation(buf);</div><div class="line">    mutation.emplace_back(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">google::cloud::bigtable::SetCell</a>(</div><div class="line">        <span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col0&quot;</span>, <span class="stringliteral">&quot;value0-&quot;</span> + std::to_string(i)));</div><div class="line">    mutation.emplace_back(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">google::cloud::bigtable::SetCell</a>(</div><div class="line">        <span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col1&quot;</span>, <span class="stringliteral">&quot;value2-&quot;</span> + std::to_string(i)));</div><div class="line">    mutation.emplace_back(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">google::cloud::bigtable::SetCell</a>(</div><div class="line">        <span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col2&quot;</span>, <span class="stringliteral">&quot;value3-&quot;</span> + std::to_string(i)));</div><div class="line">    mutation.emplace_back(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">google::cloud::bigtable::SetCell</a>(</div><div class="line">        <span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col3&quot;</span>, <span class="stringliteral">&quot;value4-&quot;</span> + std::to_string(i)));</div><div class="line">    table.Apply(std::move(mutation));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ad4ccadae90b76ffe2f78d1b49109e701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ccadae90b76ffe2f78d1b49109e701">&#9670;&nbsp;</a></span>BulkApply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void google::cloud::bigtable::v0::Table::BulkApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1BulkMutation.html">BulkMutation</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>mut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to apply mutations to multiple rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut</td><td>the mutations, note that this function takes ownership (and then discards) the data in the mutation. In general, a <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1BulkMutation.html" title="Represent a set of mutations across multiple rows. ">BulkMutation</a></code> can modify multiple rows, and the modifications for each row can change (or create) multiple cells, across different columns and column families.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1PermanentMutationFailure.html" title="Report unrecoverable errors in a partially completed mutation. ">PermanentMutationFailure</a></td><td>based on how the retry policy handles error conditions. Note that not idempotent mutations that are not reported as successful or failed by the server are not sent to the server more than once, and are reported back with a OK status in the exception. The exception contains a copy of the original mutations, in case the application wants to retry, log, or otherwise handle the failed mutations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#ad4ccadae90b76ffe2f78d1b49109e701">BulkApply</a>(google::cloud::bigtable::Table table) {</div><div class="line">  <span class="comment">// Write several rows in a single operation, each row has some trivial data.</span></div><div class="line">  google::cloud::bigtable::BulkMutation bulk;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != 5000; ++i) {</div><div class="line">    <span class="comment">// Note: This example uses sequential numeric IDs for simplicity, but</span></div><div class="line">    <span class="comment">// this can result in poor performance in a production application.</span></div><div class="line">    <span class="comment">// Since rows are stored in sorted order by key, sequential keys can</span></div><div class="line">    <span class="comment">// result in poor distribution of operations across nodes.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// For more information about how to design a Bigtable schema for the</span></div><div class="line">    <span class="comment">// best performance, see the documentation:</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//     https://cloud.google.com/bigtable/docs/schema-design</span></div><div class="line">    <span class="keywordtype">char</span> buf[32];</div><div class="line">    snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">&quot;key-%06d&quot;</span>, i);</div><div class="line">    google::cloud::bigtable::SingleRowMutation mutation(buf);</div><div class="line">    mutation.emplace_back(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">google::cloud::bigtable::SetCell</a>(</div><div class="line">        <span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col0&quot;</span>, <span class="stringliteral">&quot;value0-&quot;</span> + std::to_string(i)));</div><div class="line">    mutation.emplace_back(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">google::cloud::bigtable::SetCell</a>(</div><div class="line">        <span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col1&quot;</span>, <span class="stringliteral">&quot;value2-&quot;</span> + std::to_string(i)));</div><div class="line">    mutation.emplace_back(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">google::cloud::bigtable::SetCell</a>(</div><div class="line">        <span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col2&quot;</span>, <span class="stringliteral">&quot;value3-&quot;</span> + std::to_string(i)));</div><div class="line">    mutation.emplace_back(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">google::cloud::bigtable::SetCell</a>(</div><div class="line">        <span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col3&quot;</span>, <span class="stringliteral">&quot;value4-&quot;</span> + std::to_string(i)));</div><div class="line">    bulk.emplace_back(std::move(mutation));</div><div class="line">  }</div><div class="line">  table.BulkApply(std::move(bulk));</div><div class="line">}</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="aa75595485f6207799a52b296d4f45d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75595485f6207799a52b296d4f45d27">&#9670;&nbsp;</a></span>CheckAndMutateRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool google::cloud::bigtable::v0::Table::CheckAndMutateRow </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>row_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Mutation.html">Mutation</a> &gt;&#160;</td>
          <td class="paramname"><em>true_mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Mutation.html">Mutation</a> &gt;&#160;</td>
          <td class="paramname"><em>false_mutations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic test-and-set for a row using filter expressions. </p>
<p>Atomically check the value of a row using a filter expression. If the expression passes (meaning at least one element is returned by it), one set of mutations is applied. If the filter does not pass, a different set of mutations is applied. The changes are atomically applied in the server.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_key</td><td>the row to modify. </td></tr>
    <tr><td class="paramname">filter</td><td>the filter expression. </td></tr>
    <tr><td class="paramname">true_mutations</td><td>the mutations for the "filter passed" case. </td></tr>
    <tr><td class="paramname">false_mutations</td><td>the mutations for the "filter did not pass" case. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the filter passed.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> CheckAndMutate(google::cloud::bigtable::Table table) {</div><div class="line">  <span class="comment">// Check if the latest value of the flip-flop column is &quot;on&quot;.</span></div><div class="line">  <span class="keyword">auto</span> predicate = google::cloud::bigtable::Filter::Chain(</div><div class="line">      google::cloud::bigtable::Filter::ColumnRangeClosed(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flip-flop&quot;</span>,</div><div class="line">                                                         <span class="stringliteral">&quot;flip-flop&quot;</span>),</div><div class="line">      google::cloud::bigtable::Filter::Latest(1),</div><div class="line">      google::cloud::bigtable::Filter::ValueRegex(<span class="stringliteral">&quot;on&quot;</span>));</div><div class="line">  <span class="comment">// If the predicate matches, change the latest value to &quot;off&quot;, otherwise,</span></div><div class="line">  <span class="comment">// change the latest value to &quot;on&quot;.  Modify the &quot;flop-flip&quot; column at the</span></div><div class="line">  <span class="comment">// same time.</span></div><div class="line">  table.CheckAndMutateRow(</div><div class="line">      MAGIC_ROW_KEY, std::move(predicate),</div><div class="line">      {<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">google::cloud::bigtable::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flip-flop&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>),</div><div class="line">       <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">google::cloud::bigtable::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flop-flip&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>)},</div><div class="line">      {<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">google::cloud::bigtable::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flip-flop&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>),</div><div class="line">       <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">google::cloud::bigtable::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flop-flip&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>)});</div><div class="line">}</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="af23d1796d60442eac811eac99808ad9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23d1796d60442eac811eac99808ad9f">&#9670;&nbsp;</a></span>ReadModifyWriteRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Row.html">Row</a> google::cloud::bigtable::v0::Table::ReadModifyWriteRow </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>row_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::ReadModifyWriteRule&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically read and modify the row in the server, returning the resulting row. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>this is zero or more ReadModifyWriteRules to apply on a row </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_key</td><td>the row to read </td></tr>
    <tr><td class="paramname">rule</td><td>to modify the row. Two types of rules are applied here AppendValue which will read the existing value and append the text provided to the value. IncrementAmount which will read the existing uint64 big-endian-int and add the value provided. Both rules accept the family and column identifier to modify. </td></tr>
    <tr><td class="paramname">rules</td><td>is the zero or more ReadModifyWriteRules to apply on a row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>modified row</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> ReadModifyWrite(google::cloud::bigtable::Table table) {</div><div class="line">  <span class="keyword">auto</span> row = table.ReadModifyWriteRow(</div><div class="line">      MAGIC_ROW_KEY,</div><div class="line">      google::cloud::bigtable::ReadModifyWriteRule::IncrementAmount(</div><div class="line">          <span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;counter&quot;</span>, 1),</div><div class="line">      google::cloud::bigtable::ReadModifyWriteRule::AppendValue(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;list&quot;</span>,</div><div class="line">                                                                <span class="stringliteral">&quot;;element&quot;</span>));</div><div class="line">  std::cout &lt;&lt; row.row_key() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; cell : row.cells()) {</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="a6170060c579d2fbd6b29a4ba6f7de434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6170060c579d2fbd6b29a4ba6f7de434">&#9670;&nbsp;</a></span>ReadRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Row.html">Row</a> &gt; google::cloud::bigtable::v0::Table::ReadRow </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>row_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and return a single row from the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_key</td><td>the row to read. </td></tr>
    <tr><td class="paramname">filter</td><td>a filter expression, can be used to select a subset of the column families and columns in the row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple, the first element is a boolean, with value <code>false</code> if the row does not exist. If the first element is <code>true</code> the second element has the contents of the <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Row.html" title="The in-memory representation of a Bigtable row. ">Row</a>. Note that the contents may be empty if the filter expression removes all column families and columns.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a6170060c579d2fbd6b29a4ba6f7de434">ReadRow</a>(google::cloud::bigtable::Table table) {</div><div class="line">  <span class="comment">// Filter the results, only include the latest value on each cell.</span></div><div class="line">  <span class="keyword">auto</span> filter = google::cloud::bigtable::Filter::Latest(1);</div><div class="line">  <span class="comment">// Read a row, this returns a tuple (bool, row)</span></div><div class="line">  std::pair&lt;bool, google::cloud::bigtable::Row&gt; tuple =</div><div class="line">      table.ReadRow(MAGIC_ROW_KEY, std::move(filter));</div><div class="line">  <span class="keywordflow">if</span> (not tuple.first) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Row &quot;</span> &lt;&lt; MAGIC_ROW_KEY &lt;&lt; <span class="stringliteral">&quot; not found&quot;</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;key: &quot;</span> &lt;&lt; tuple.second.row_key() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; cell : tuple.second.cells()) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; cell.family_name() &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; cell.column_qualifier()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; = &lt;&quot;</span>;</div><div class="line">    <span class="keywordflow">if</span> (cell.column_qualifier() == <span class="stringliteral">&quot;counter&quot;</span>) {</div><div class="line">      <span class="comment">// This example uses &quot;counter&quot; to store 64-bit numbers in BigEndian</span></div><div class="line">      <span class="comment">// format, extract them as follows:</span></div><div class="line">      std::cout</div><div class="line">          &lt;&lt; cell.value_as&lt;google::cloud::bigtable::bigendian64_t&gt;().<span class="keyword">get</span>();</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">      std::cout &lt;&lt; cell.value();</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;&gt;\n&quot;</span>;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; std::flush;</div><div class="line">}</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="a07fd0b3bc5b4fc17db8e3f099aaf9c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07fd0b3bc5b4fc17db8e3f099aaf9c33">&#9670;&nbsp;</a></span>ReadRows() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RowReader.html">RowReader</a> google::cloud::bigtable::v0::Table::ReadRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RowSet.html">RowSet</a>&#160;</td>
          <td class="paramname"><em>row_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a set of rows from the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_set</td><td>the rows to read from. </td></tr>
    <tr><td class="paramname">filter</td><td>is applied on the server-side to data in the rows.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a07fd0b3bc5b4fc17db8e3f099aaf9c33">ReadRows</a>(google::cloud::bigtable::Table table) {</div><div class="line">  <span class="comment">// Create the range of rows to read.</span></div><div class="line">  <span class="keyword">auto</span> range =</div><div class="line">      google::cloud::bigtable::RowRange::Range(<span class="stringliteral">&quot;key-000010&quot;</span>, <span class="stringliteral">&quot;key-000020&quot;</span>);</div><div class="line">  <span class="comment">// Filter the results, only include values from the &quot;col0&quot; column in the</span></div><div class="line">  <span class="comment">// &quot;fam&quot; column family, and only get the latest value.</span></div><div class="line">  <span class="keyword">auto</span> filter = google::cloud::bigtable::Filter::Chain(</div><div class="line">      google::cloud::bigtable::Filter::ColumnRangeClosed(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col0&quot;</span>, <span class="stringliteral">&quot;col0&quot;</span>),</div><div class="line">      google::cloud::bigtable::Filter::Latest(1));</div><div class="line">  <span class="comment">// Read and print the rows.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; row : table.ReadRows(range, filter)) {</div><div class="line">    <span class="keywordflow">if</span> (row.cells().size() != 1) {</div><div class="line">      std::ostringstream os;</div><div class="line">      os &lt;&lt; <span class="stringliteral">&quot;Unexpected number of cells in &quot;</span> &lt;&lt; row.row_key();</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(os.str());</div><div class="line">    }</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span>&amp; cell = row.cells().at(0);</div><div class="line">    std::cout &lt;&lt; cell.row_key() &lt;&lt; <span class="stringliteral">&quot; = [&quot;</span> &lt;&lt; cell.value() &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; std::flush;</div><div class="line">}</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="a95295dc0c3dd50603926b6038160a071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95295dc0c3dd50603926b6038160a071">&#9670;&nbsp;</a></span>ReadRows() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RowReader.html">RowReader</a> google::cloud::bigtable::v0::Table::ReadRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RowSet.html">RowSet</a>&#160;</td>
          <td class="paramname"><em>row_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>rows_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a limited set of rows from the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_set</td><td>the rows to read from. </td></tr>
    <tr><td class="paramname">rows_limit</td><td>the maximum number of rows to read. Must be larger than zero. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a07fd0b3bc5b4fc17db8e3f099aaf9c33" title="Reads a set of rows from the table. ">ReadRows(RowSet, Filter)</a></code> to read all matching rows. </td></tr>
    <tr><td class="paramname">filter</td><td>is applied on the server-side to data in the rows.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if rows_limit is &lt; 0. rows_limit = 0(default) will return all rows</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> ReadRowsWithLimit(google::cloud::bigtable::Table table) {</div><div class="line">  <span class="comment">// Create the range of rows to read.</span></div><div class="line">  <span class="keyword">auto</span> range =</div><div class="line">      google::cloud::bigtable::RowRange::Range(<span class="stringliteral">&quot;key-000010&quot;</span>, <span class="stringliteral">&quot;key-000020&quot;</span>);</div><div class="line">  <span class="comment">// Filter the results, only include values from the &quot;col0&quot; column in the</span></div><div class="line">  <span class="comment">// &quot;fam&quot; column family, and only get the latest value.</span></div><div class="line">  <span class="keyword">auto</span> filter = google::cloud::bigtable::Filter::Chain(</div><div class="line">      google::cloud::bigtable::Filter::ColumnRangeClosed(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col0&quot;</span>, <span class="stringliteral">&quot;col0&quot;</span>),</div><div class="line">      google::cloud::bigtable::Filter::Latest(1));</div><div class="line">  <span class="comment">// Read and print the first 5 rows in the range.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; row : table.ReadRows(range, 5, filter)) {</div><div class="line">    <span class="keywordflow">if</span> (row.cells().size() != 1) {</div><div class="line">      std::ostringstream os;</div><div class="line">      os &lt;&lt; <span class="stringliteral">&quot;Unexpected number of cells in &quot;</span> &lt;&lt; row.row_key();</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(os.str());</div><div class="line">    }</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span>&amp; cell = row.cells().at(0);</div><div class="line">    std::cout &lt;&lt; cell.row_key() &lt;&lt; <span class="stringliteral">&quot; = [&quot;</span> &lt;&lt; cell.value() &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; std::flush;</div><div class="line">}</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ad13ee373480b6eded62945b506a4e753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13ee373480b6eded62945b506a4e753">&#9670;&nbsp;</a></span>SampleRows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename... &gt; class Collection = std::vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Collection&lt;bigtable::RowKeySample&gt; google::cloud::bigtable::v0::Table::SampleRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sample of the row keys in the table, including approximate data sizes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Collection</td><td>the type of collection where the samples are returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Note that the sample may only include one element for small tables. In addition, the sample may include row keys that do not exist on the table, and may include the empty row key to indicate "end of table".</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#ad13ee373480b6eded62945b506a4e753">SampleRows</a>(google::cloud::bigtable::Table table) {</div><div class="line">  <span class="keyword">auto</span> samples = table.SampleRows&lt;&gt;();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; sample : samples) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;key=&quot;</span> &lt;&lt; sample.row_key &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; sample.offset_bytes</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; std::flush;</div><div class="line">}</div></div><!-- fragment --> In addition, application developers can specify other collection types, for example <code>std::list&lt;&gt;</code> or <code>std::deque&lt;&gt;</code>: <div class="fragment"><div class="line"><span class="keywordtype">void</span> SampleRowsCollections(google::cloud::bigtable::Table table) {</div><div class="line">  <span class="keyword">auto</span> list_samples = table.SampleRows&lt;std::list&gt;();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; sample : list_samples) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;key=&quot;</span> &lt;&lt; sample.row_key &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; sample.offset_bytes</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keyword">auto</span> deque_samples = table.SampleRows&lt;std::deque&gt;();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; sample : deque_samples) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;key=&quot;</span> &lt;&lt; sample.row_key &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; sample.offset_bytes</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; std::flush;</div><div class="line">}</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="a1a84118bf4f098d5a4785b586484ab14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a84118bf4f098d5a4785b586484ab14">&#9670;&nbsp;</a></span>table_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string const&amp; google::cloud::bigtable::v0::Table::table_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="table_8h_source.html">table.h</a></li>
<li><a class="el" href="table_8cc.html">table.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
